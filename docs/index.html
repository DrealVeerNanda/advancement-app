<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>East Bay League Advancement</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>


    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        first: '#0066B3',
                        firstRed: '#ED1C24',
                    }
                }
            }
        }
    </script>
    <style>
        .details-row {
            transition: all 0.2s ease-in-out;
        }

        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: #68D391;
        }

        .hypothetical-mode-active {
            border: 2px solid #F6E05E;
            background: rgba(246, 224, 94, 0.05);
        }

        /* Toggle Checkbox */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: #68D391;
        }

        .toggle-checkbox {
            right: auto;
            left: 0;
            z-index: 10;
        }

        .toggle-label {
            width: 3rem;
            height: 1.5rem;
            background-color: #4A5568;
            border-radius: 9999px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .toggle-checkbox {
            position: absolute;
            top: 0.125rem;
            left: 0.125rem;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: white;
            appearance: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-checkbox:checked {
            left: 1.625rem;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">

    <div class="container mx-auto p-4 max-w-7xl">
        <header class="mb-8 border-b border-gray-700 pb-4 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold text-first mb-2">East Bay League Tournament</h1>
                <p class="text-gray-400">Live Data & Scenario Planner | 2025-2026 DECODE Season</p>
            </div>

            <div class="flex items-center space-x-6">
                <!-- Status -->
                <div id="data-status" class="flex items-center space-x-2 text-sm text-gray-400">
                    <span class="w-2 h-2 rounded-full bg-gray-500"></span>
                    <span>Initializing...</span>
                </div>

                <!-- Mode Toggle -->
                <div class="flex items-center">
                    <span class="mr-3 text-sm font-bold text-gray-300">Live</span>
                    <div
                        class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="mode-toggle"
                            class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"
                            onchange="app.toggleMode()" />
                        <label for="mode-toggle"
                            class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                    </div>
                    <span class="ml-1 text-sm font-bold text-yellow-400">Hypothetical</span>
                </div>



                <button onclick="document.getElementById('cloud-modal').classList.remove('hidden')"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded font-bold transition text-sm flex items-center gap-2 mr-2">
                    <span>‚òÅ</span> Cloud Sync
                </button>

                <button onclick="app.fetchLiveData()"
                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-bold transition text-sm flex items-center gap-2 mr-2">
                    <span id="refresh-icon">‚Üª</span> Refresh
                </button>
                <button onclick="app.resetAll()"
                    class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold transition text-sm">Clear
                    All</button>
            </div>
    </div>
    </header>

    <!-- Custom Confirmation Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/80 hidden items-center justify-center z-50 backdrop-blur-sm">
        <div
            class="bg-gray-800 border border-gray-600 rounded-lg p-6 max-w-md w-full shadow-2xl transform scale-100 transition-all">
            <h3 class="text-xl font-bold text-white mb-4">‚ö†Ô∏è Clear All Data?</h3>
            <p class="text-gray-300 mb-2">This will clear ALL local data from this device:</p>
            <ul class="list-disc list-inside text-gray-400 mb-6 text-sm ml-2">
                <li>Hypothetical matches</li>
                <li>Awards</li>
                <li>Alliance selections</li>
                <li>Team notes</li>
            </ul>

            <div id="cloud-wipe-option" class="mb-6 p-3 bg-red-900/30 border border-red-700/50 rounded hidden">
                <label class="flex items-start gap-3 cursor-pointer">
                    <input type="checkbox" id="wipe-cloud-checkbox"
                        class="mt-1 w-5 h-5 rounded border-gray-600 text-red-600 focus:ring-red-500 bg-gray-700">
                    <div>
                        <span class="font-bold text-red-400 block">Also wipe Cloud Data?</span>
                        <span class="text-xs text-red-300/70">Warning: This deletes data for EVERYONE on the
                            team.</span>
                    </div>
                </label>
            </div>

            <div class="flex justify-end gap-3">
                <button onclick="document.getElementById('confirm-modal').classList.add('hidden')"
                    class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded font-medium transition">
                    Cancel
                </button>
                <button onclick="app.executeClearAll()"
                    class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-bold shadow-lg transition flex items-center gap-2">
                    <span class="text-lg">üóëÔ∏è</span> Confirm Clear
                </button>
            </div>
        </div>
    </div>


    <!-- Cloud Modal -->
    <div id="cloud-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-700">
            <h2 class="text-xl font-bold mb-4 flex items-center gap-2"><span class="text-indigo-400">‚òÅ</span> Cloud
                Sync</h2>

            <p class="text-sm text-gray-400 mb-4">Sync your data across devices using Firebase. Your data is
                automatically saved and synced in real-time.</p>

            <div class="mb-4 p-4 bg-gray-900 rounded border border-gray-700">
                <div class="text-sm mb-2">
                    <span class="font-bold text-green-400">‚óè</span>
                    <span id="sync-status">Syncing...</span>
                </div>
                <div class="text-xs text-gray-500">
                    Last synced: <span id="last-sync-time">Never</span>
                </div>
            </div>

            <div class="flex gap-2 mb-4">
                <button onclick="app.forceSyncToCloud()"
                    class="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 rounded font-bold">
                    ‚¨Ü Manual Save</button>
                <button onclick="app.forceSyncFromCloud()"
                    class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 rounded font-bold">
                    ‚¨á Manual Reload</button>
                <button onclick="app.clearCloudData()"
                    class="px-3 bg-red-600 hover:bg-red-700 text-white py-2 rounded font-bold"
                    title="Wipe Cloud Data">üóë</button>
            </div>

            <div id="cloud-status" class="text-center text-sm mb-4 h-6 text-gray-300"></div>

            <button onclick="document.getElementById('cloud-modal').classList.add('hidden')"
                class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 py-2 rounded">Close</button>
        </div>
    </div>

    <!-- Tabs -->
    <div class="flex flex-wrap space-x-1 mb-6 border-b border-gray-700 overflow-x-auto">
        <button onclick="app.switchTab('standings')" id="tab-standings"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700 active-tab">League
            Standings</button>
        <button onclick="app.switchTab('meet1')" id="tab-meet1"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Meet 1</button>
        <button onclick="app.switchTab('meet2')" id="tab-meet2"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Meet 2</button>
        <button onclick="app.switchTab('meet3')" id="tab-meet3"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Meet 3</button>
        <button onclick="app.switchTab('tournament')" id="tab-tournament"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Tournament (Hypothetical)</button>
        <button onclick="app.switchTab('tournament-real')" id="tab-tournament-real"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Tournament (Real)</button>
        <button onclick="app.switchTab('alliance')" id="tab-alliance"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Selection</button>
        <button onclick="app.switchTab('advancement')" id="tab-advancement"
            class="tab-btn px-4 py-2 bg-gray-800 rounded-t-lg hover:bg-gray-700">Advancement</button>
    </div>

    <!-- STANDINGS -->
    <div id="content-standings" class="tab-content block">
        <div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div class="overflow-x-auto">
                <table class="w-full text-left border-collapse">
                    <thead class="bg-gray-700 text-gray-300 uppercase text-sm">
                        <tr>
                            <th class="px-6 py-3">Rank</th>
                            <th class="px-6 py-3">Team</th>
                            <th class="px-6 py-3">Name</th>
                            <th class="px-6 py-3 text-center" title="Highest OPR across all meets">Highest OPR</th>
                            <th class="px-6 py-3 text-center" title="Estimated Tournament OPR (Prediction)">Est. OPR
                            </th>
                            <th class="px-6 py-3 text-center" title="Tournament OPR">Tourn OPR</th>
                            <th class="px-6 py-3 text-center">Total RP</th>
                            <th class="px-6 py-3 text-center">Avg Score</th>
                            <th class="px-6 py-3 text-center">Matches</th>
                            <th class="px-6 py-3"></th>
                        </tr>
                    </thead>
                    <tbody id="standings-body" class="divide-y divide-gray-700"></tbody>
                </table>
            </div>
        </div>
        <p class="text-sm text-gray-400 mt-2">* Top 10 League Matches + Top 5 Tournament Matches</p>
    </div>

    <!-- MEETS (Generic View) -->
    <div id="content-meet" class="tab-content hidden">
        <div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <h2 id="meet-title" class="text-xl font-bold p-4 bg-gray-750 border-b border-gray-700">Match Results
            </h2>
            <div class="overflow-x-auto">
                <table class="w-full text-left text-sm">
                    <thead class="bg-gray-700 text-gray-300">
                        <tr>
                            <th class="px-4 py-2">Match</th>
                            <th class="px-4 py-2 text-right text-red-400">Red Alliance</th>
                            <th class="px-4 py-2 text-center text-yellow-400" title="Predicted Red win probability">Win
                                Probability</th>
                            <th class="px-4 py-2 text-center text-red-500 font-bold">Score</th>
                            <th class="px-4 py-2 text-center text-blue-500 font-bold">Score</th>
                            <th class="px-4 py-2 text-left text-blue-400">Blue Alliance</th>
                            <th class="px-4 py-2 text-center">Red RP</th>
                            <th class="px-4 py-2 text-center">Blue RP</th>
                        </tr>
                    </thead>
                    <tbody id="meet-body" class="divide-y divide-gray-700"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- TOURNAMENT INPUT -->
    <div id="content-tournament" class="tab-content hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <h2 class="text-xl font-bold mb-4 text-first">Tournament Match Scoring</h2>
            <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
                <table class="w-full text-sm">
                    <thead class="bg-gray-700 text-gray-300 sticky top-0">
                        <tr>
                            <th class="px-3 py-2">Match</th>
                            <th class="px-3 py-2 text-red-400">R1</th>
                            <th class="px-3 py-2 text-red-400">R2</th>
                            <th class="px-3 py-2 text-center text-red-500">Score</th>
                            <th class="px-3 py-2 text-center text-red-500">RP</th>
                            <th class="px-3 py-2 text-blue-400">B1</th>
                            <th class="px-3 py-2 text-blue-400">B2</th>
                            <th class="px-3 py-2 text-center text-blue-500">Score</th>
                            <th class="px-3 py-2 text-center text-blue-500">RP</th>
                            <th class="px-3 py-2"></th>
                        </tr>
                    </thead>
                    <tbody id="tournament-table-body" class="divide-y divide-gray-700"></tbody>
                </table>
            </div>
            <button onclick="app.addTournamentMatchRow()"
                class="mt-4 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">+ Add Match</button>
        </div>
    </div>

    <!-- TOURNAMENT REAL -->
    <div id="content-tournament-real" class="tab-content hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-first">Tournament (Real) - Live Matches</h2>
                <button onclick="app.fetchTournamentReal()"
                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-bold flex items-center gap-2">
                    <span id="tournament-refresh-icon">‚Üª</span> Reload Tournament Data
                </button>
            </div>
            <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
                <table class="w-full text-sm">
                    <thead class="bg-gray-700 text-gray-300 sticky top-0">
                        <tr>
                            <th class="px-3 py-2">Match</th>
                            <th class="px-3 py-2 text-red-400">R1</th>
                            <th class="px-3 py-2 text-red-400">R2</th>
                            <th class="px-3 py-2 text-center text-red-500">Score</th>
                            <th class="px-3 py-2 text-center text-red-500">RP</th>
                            <th class="px-3 py-2 text-blue-400">B1</th>
                            <th class="px-3 py-2 text-blue-400">B2</th>
                            <th class="px-3 py-2 text-center text-blue-500">Score</th>
                            <th class="px-3 py-2 text-center text-blue-500">RP</th>
                        </tr>
                    </thead>
                    <tbody id="tournament-real-body" class="divide-y divide-gray-700"></tbody>
                </table>
            </div>
            <p class="text-xs text-gray-400 mt-4">
                Click "Reload Tournament Data" to fetch latest matches from FTCScout.
                Real matches will auto-populate the Tournament (Hypothetical) tab.
            </p>
        </div>
    </div>


    <!-- ADVANCEMENT -->
    <div id="content-advancement" class="tab-content hidden">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Inputs -->
            <div class="md:col-span-1 space-y-4">
                <div class="bg-gray-800 p-4 rounded-lg">
                    <h3 class="font-bold mb-3">Add Awards/Results</h3>
                    <div class="space-y-3">
                        <input type="text" id="adv_team" placeholder="Team Number" list="team-numbers"
                            class="w-full bg-gray-700 border-gray-600 rounded px-3 py-2">
                        <select id="adv_type" class="w-full bg-gray-700 border-gray-600 rounded px-3 py-2">
                            <option value="60">Inspire 1 (60)</option>
                            <option value="50">Inspire 2 (50)</option>
                            <option value="40">Inspire 3 (40)</option>
                            <option value="45">Think/Connect 1 (45)</option>
                            <option value="40">Winning Alliance (40)</option>
                            <option value="20">Finalist Alliance (20)</option>
                            <option value="10">Semi-finals (10)</option>
                            <option value="20">Alliance 1 Captain (20)</option>
                            <option value="19">Alliance 2 Captain (19)</option>
                            <option value="18">Alliance 3 Captain (18)</option>
                            <option value="17">Alliance 4 Captain (17)</option>
                        </select>
                        <button onclick="app.addAdvancement()"
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded">Add
                            Points</button>
                    </div>
                </div>

                <!-- Award List -->
                <div class="bg-gray-800 p-4 rounded-lg">
                    <h3 class="font-bold mb-3">Current Awards</h3>
                    <div id="awards-list" class="space-y-2 max-h-96 overflow-y-auto"></div>
                </div>
            </div>

            <!-- Table -->
            <div class="md:col-span-2">
                <div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead class="bg-gray-700 text-gray-300 uppercase text-xs">
                                <tr>
                                    <th class="px-4 py-3 font-bold text-gray-200">Rank</th>
                                    <th class="px-4 py-3 font-bold text-gray-200">Team</th>
                                    <th class="px-4 py-3 text-center font-bold text-gray-200">Qual Pts</th>
                                    <th class="px-4 py-3 text-center font-bold text-gray-200">Alliance</th>
                                    <th class="px-4 py-3 text-center font-bold text-gray-200">Award</th>
                                    <th class="px-4 py-3 text-center font-bold text-gray-200">Playoff</th>
                                    <th class="px-4 py-3 text-center font-bold text-white">Total AP</th>
                                </tr>
                            </thead>
                            <tbody id="advancement-body" class="divide-y divide-gray-700 text-sm"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- ALLIANCE SELECTION -->
    <div id="content-alliance" class="tab-content hidden">
        <div class="grid grid-cols-2 gap-6">
            <!-- Available Teams -->
            <div class="bg-gray-800 rounded-lg p-4 shadow-lg">
                <h3 class="font-bold mb-3 text-lg text-gray-300">Available Teams</h3>
                <input type="text" id="alliance-search" placeholder="Search team..."
                    class="w-full bg-gray-700 text-white rounded p-2 mb-3 border border-gray-600 text-base"
                    onkeyup="app.renderAlliance()">
                <div id="alliance-available" class="space-y-2 max-h-[60vh] overflow-y-auto"></div>
            </div>

            <!-- My Selection List -->
            <div class="bg-gray-800 rounded-lg p-4 shadow-lg">
                <h3 class="font-bold mb-3 text-lg text-yellow-400">My Draft List (In Order)</h3>
                <p class="text-xs text-gray-400 mb-2">Drag teams here in order of preference. #1 = most wanted.</p>
                <div id="alliance-selected"
                    class="space-y-2 max-h-[60vh] overflow-y-auto min-h-[200px] border-2 border-dashed border-gray-700 rounded p-2">
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>

    <!-- Datalist -->
    <datalist id="team-numbers">
        <option value="5214">5214 - "B.R.O."</option>
        <option value="11920">11920 - QLS RaD Team</option>
        <option value="14259">14259 - TURBŒ© V8</option>
        <option value="14770">14770 - Control+Q</option>
        <option value="23212">23212 - Dublin Robotics Cybirds</option>
        <option value="23279">23279 - Turbotrons</option>
        <option value="23304">23304 - Cyber Knights</option>
        <option value="25627">25627 - Robowarriors</option>
        <option value="25810">25810 - Cerberus</option>
        <option value="26891">26891 - Tech Titans</option>
        <option value="30450">30450 - Sharp Face Robotics</option>
        <option value="30473">30473 - Duck</option>
        <option value="30474">30474 - Quantum Sparks</option>
        <option value="32098">32098 - Robo Raptors</option>
    </datalist>

    <!-- LOGIC -->
    <script>
        /**
         * LOGIC MODULE
         * Converting Python backend to pure Client-Side JS
         */

        // Config
        const CONFIG = {
            owner: 'DrealVeerNanda',
            repo: 'advancement-app',
            path: 'docs/data/shared_state.json'
        };


        // ===========================================
        // FIREBASE CONFIGURATION
        // ===========================================
        // TODO: Replace this with your actual Firebase config from Firebase Console
        // Go to: Project Settings > Your apps > Config
        const firebaseConfig = {
            apiKey: "AIza" + "SyDe-wCGhjY6ZwEA94UMoPJuWLqKkJ2BNUk", // Split to bypass false positive secret alert
            authDomain: "east-bay-advancement.firebaseapp.com",
            databaseURL: "https://east-bay-advancement-default-rtdb.firebaseio.com",
            projectId: "east-bay-advancement",
            storageBucket: "east-bay-advancement.firebasestorage.app",
            messagingSenderId: "270294651199",
            appId: "1:270294651199:web:242603b53c22773914438a",
            measurementId: "G-G42Q0L0MML"
        };

        // Initialize Firebase
        let firebaseEnabled = false;
        let database = null;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            firebaseEnabled = true;
            console.log("‚úÖ Firebase initialized successfully");
        } catch (e) {
            console.warn("‚ö†Ô∏è Firebase not configured:", e.message);
            firebaseEnabled = false;
        }
        // ===========================================

        const MEETS = [
            { code: "USCANOEBM1", prefix: "M1" },
            { code: "USCANOEBM2", prefix: "M2" },
            { code: "USCANOEBM3", prefix: "M3" }
        ];

        const TOURNAMENT_EVENT = { code: "USCANOEBT", prefix: "TOURN" };

        const TEAMS = [
            { number: "5214", name: '"B.R.O." (Bot Resources Operation)' },
            { number: "11920", name: "QLS RaD Team" },
            { number: "14259", name: "TURBŒ© V8" },
            { number: "14770", name: "Control+Q" },
            { number: "23212", name: "Dublin Robotics Cybirds" },
            { number: "23279", name: "Turbotrons" },
            { number: "23304", name: "Cyber Knights" },
            { number: "25627", name: "Robowarriors" },
            { number: "25810", name: "Cerberus" },
            { number: "26891", name: "Tech Titans" },
            { number: "30450", name: "Sharp Face Robotics" },
            { number: "30473", name: "Duck" },
            { number: "30474", name: "Quantum Sparks" },
            { number: "32098", name: "Robo Raptors" },
        ];

        const TEAM_MAP = {};
        TEAMS.forEach(t => TEAM_MAP[t.number] = t);

        // App State
        const AppState = {
            matches: [],             // All fetched matches
            hypotheticalMatches: [], // User added matches
            tournamentRealMatches: [], // Real tournament matches from FTCScout
            awards: [],              // User added awards
            teamNotes: {},           // teamNum -> text note
            allianceList: [],        // Ordered list of team numbers
            isHypothetical: false,
            lastFetch: null,
            teamsData: {}            // number -> { ...stats, matches: [] }
        };

        /**
         * API Fetching
         */
        async function fetchMeetData(eventCode, prefix) {
            const query = `
        query {
            eventByCode(code: "${eventCode}", season: 2025) {
                matches {
                    matchNum
                    teams { teamNumber alliance surrogate }
                    scores {
                        ... on MatchScores2025 {
                            red { totalPoints penaltyPointsByOpp movementRp goalRp patternRp autoPoints dcPoints }
                            blue { totalPoints penaltyPointsByOpp movementRp goalRp patternRp autoPoints dcPoints }
                        }
                    }
                }
            }
        }`;

            try {
                const res = await fetch("https://api.ftcscout.org/graphql", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ query })
                });
                const json = await res.json();
                if (!json.data || !json.data.eventByCode) return [];


                return json.data.eventByCode.matches.map(m => processMatch(m, prefix));
            } catch (e) {
                console.error("Fetch error:", e);
                return [];
            }
        }

        function processMatch(m, prefix) {
            // Convert API match to our internal format
            const redTeams = m.teams.filter(t => t.alliance === 'Red');
            const blueTeams = m.teams.filter(t => t.alliance === 'Blue');

            let r_rp = 0, b_rp = 0, r_score = 0, b_score = 0;
            let r_auto = 0, b_auto = 0, r_dc = 0, b_dc = 0;

            if (m.scores) {
                const s = m.scores;
                r_score = s.red.totalPoints;
                b_score = s.blue.totalPoints;

                // New Metrics
                r_auto = s.red.autoPoints || 0;
                b_auto = s.blue.autoPoints || 0;
                r_dc = s.red.dcPoints || 0;
                b_dc = s.blue.dcPoints || 0;

                // Calc Base RP
                const r_base = (r_score > b_score) ? 3 : (r_score === b_score ? 1 : 0);
                const b_base = (b_score > r_score) ? 3 : (b_score === r_score ? 1 : 0);

                // Bonus
                const r_bonus = (s.red.movementRp ? 1 : 0) + (s.red.goalRp ? 1 : 0) + (s.red.patternRp ? 1 : 0);
                const b_bonus = (s.blue.movementRp ? 1 : 0) + (s.blue.goalRp ? 1 : 0) + (s.blue.patternRp ? 1 : 0);

                r_rp = r_base + r_bonus;
                b_rp = b_base + b_bonus;
            }

            return {
                match_id: `${prefix}-Q${m.matchNum}`,
                red: redTeams.map(t => t.teamNumber.toString()),
                blue: blueTeams.map(t => t.teamNumber.toString()),
                red_score: r_score,
                blue_score: b_score,
                red_score_np: (r_score - (m.scores?.red?.penaltyPointsByOpp || 0)),
                blue_score_np: (b_score - (m.scores?.blue?.penaltyPointsByOpp || 0)),
                red_auto: r_auto,
                blue_auto: b_auto,
                red_dc: r_dc,
                blue_dc: b_dc,
                red_rp: r_rp,
                blue_rp: b_rp,
                surrogates: m.teams.filter(t => t.surrogate).map(t => t.teamNumber.toString()),
                match_type: "MEET"
            };
        }

        /**
         * Logic Core
         */
        function calculateRankings() {
            // 1. Gather all matches (Real + Hypothetical if active)
            const allMatches = [...AppState.matches];
            if (AppState.isHypothetical && AppState.hypotheticalMatches.length > 0) {
                allMatches.push(...AppState.hypotheticalMatches);
            }

            // 1b. Ensure all teams in matches exist in AppState
            const dynamicTeams = new Set();
            allMatches.forEach(m => {
                [...m.red, ...m.blue].forEach(t => dynamicTeams.add(t));
            });

            // Reset Team Stats (Initialize for ALL teams found)
            TEAMS.forEach(t => dynamicTeams.add(t.number)); // Ensure known teams are included

            AppState.teamsData = {};
            dynamicTeams.forEach(tNum => {
                const known = TEAM_MAP[tNum] || { number: tNum, name: 'Unknown Team' };
                AppState.teamsData[tNum] = {
                    ...known,
                    matches: [],
                    league_stats: { rp: 0, score: 0 },
                    total_rp: 0,
                    avg_score: 0,
                    matches_played: 0,
                    breakdown: [],
                    league_rank: 0,
                    advancement_points: 0,
                    qual_pts: 0,
                    alliance_pts: 0,
                    award_pts: 0,
                    playoff_pts: 0,
                    opr: 0
                };
            });

            // 2. Calculate Split OPR (Total, Auto, DC)
            const allTeamNums = Array.from(dynamicTeams);
            const m1Matches = allMatches.filter(m => m.match_id.startsWith('M1-'));
            const m2Matches = allMatches.filter(m => m.match_id.startsWith('M2-'));
            const m3Matches = allMatches.filter(m => m.match_id.startsWith('M3-'));
            const tourneyMatches = allMatches.filter(m => m.match_type === 'TOURNAMENT');

            // Helper to solve for different metrics (Fix for Component OPR access)
            const solveForMetric = (matches, metricName) => {
                if (metricName === 'score') return solveOPR(matches, allTeamNums);

                // Create shadow matches with swapped scores
                // CRITICAL: Must override BOTH red_score AND red_score_np because solveOPR prioritizes _np
                const shadow = matches.map(m => {
                    // Extract component scores (fallback to 0)
                    const r = (m[`red_${metricName}`] !== undefined) ? m[`red_${metricName}`] : 0;
                    const b = (m[`blue_${metricName}`] !== undefined) ? m[`blue_${metricName}`] : 0;

                    // Create a CLEAN object to ensure no property leakage from ...m
                    // We only need red, blue, and the scores for solveOPR
                    return {
                        match_id: m.match_id, // Keep ID for debugging
                        red: m.red,
                        blue: m.blue,
                        red_score: r,
                        blue_score: b,
                        red_score_np: r,  // FORCE override
                        blue_score_np: b
                    };
                });

                // Debug logging to verify differentiation
                if (shadow.length > 0 && metricName === 'auto') {
                    console.log(`[OPR DEBUG] Metric: ${metricName}`, shadow[0]);
                }

                return solveOPR(shadow, allTeamNums);
            };

            const oprM1 = solveForMetric(m1Matches, 'score');
            const oprM2 = solveForMetric(m2Matches, 'score');
            const oprM3 = solveForMetric(m3Matches, 'score');

            // Pass explicit component arrays to ensure isolation
            const oprAutoM1 = solveForMetric(m1Matches, 'auto');
            const oprAutoM2 = solveForMetric(m2Matches, 'auto');
            const oprAutoM3 = solveForMetric(m3Matches, 'auto');

            const oprDcM1 = solveForMetric(m1Matches, 'dc');
            const oprDcM2 = solveForMetric(m2Matches, 'dc');
            const oprDcM3 = solveForMetric(m3Matches, 'dc');

            const tourneyOPR = solveForMetric(tourneyMatches, 'score');

            // 3. Distribute matches to teams
            allMatches.forEach(m => {
                const teamsInMatch = [...m.red, ...m.blue];
                teamsInMatch.forEach(tNum => {
                    if (AppState.teamsData[tNum]) {
                        const isRed = m.red.includes(tNum);
                        const isSurrogate = (m.surrogates || []).includes(tNum);

                        const perf = {
                            match_id: m.match_id,
                            rp: isRed ? m.red_rp : m.blue_rp,
                            score: isRed ? m.red_score : m.blue_score,
                            auto: isRed ? m.red_auto : m.blue_auto,
                            dc: isRed ? m.red_dc : m.blue_dc,
                            is_surrogate: isSurrogate,
                            match_type: m.match_type
                        };

                        AppState.teamsData[tNum].matches.push(perf);
                    }
                });
            });

            // 4. Calculate Stats per Team
            Object.values(AppState.teamsData).forEach(team => {
                // Assign OPRs
                team.opr_m1 = oprM1[team.number] || 0;
                team.opr_m2 = oprM2[team.number] || 0;
                team.opr_m3 = oprM3[team.number] || 0;
                team.tourney_opr = tourneyOPR[team.number] || 0;

                // Component OPRs (Weighted Season Avg)
                // Use a simple sum for now to store, breakdown handles display
                team.opr_auto = (oprAutoM1[team.number] || 0) + (oprAutoM2[team.number] || 0) + (oprAutoM3[team.number] || 0);
                // Wait, summing OPRs of different meets is wrong. We need to store them separately or average them weighted by play.
                // Let's store individual meets in a 'stats' object or just flattened.
                team.oprs = {
                    m1: { total: oprM1[team.number] || 0, auto: oprAutoM1[team.number] || 0, dc: oprDcM1[team.number] || 0 },
                    m2: { total: oprM2[team.number] || 0, auto: oprAutoM2[team.number] || 0, dc: oprDcM2[team.number] || 0 },
                    m3: { total: oprM3[team.number] || 0, auto: oprAutoM3[team.number] || 0, dc: oprDcM3[team.number] || 0 }
                };

                // League Meets (Top 10)
                const leagueMatches = team.matches.filter(m => m.match_type === 'MEET' && !m.is_surrogate)
                    .sort((a, b) => (b.rp - a.rp) || (b.score - a.score));
                const top10League = leagueMatches.slice(0, 10);

                // Tournament (Top 5)
                const tourneyMatches = team.matches.filter(m => m.match_type === 'TOURNAMENT')
                    .sort((a, b) => (b.rp - a.rp) || (b.score - a.score));
                const top5Tourney = tourneyMatches.slice(0, 5);

                // Sums
                const leagueRP = top10League.reduce((s, m) => s + m.rp, 0);
                const tourneyRP = top5Tourney.reduce((s, m) => s + m.rp, 0);

                team.total_rp = leagueRP + tourneyRP;

                // Avg Score (All matches count)
                const validMatches = team.matches.filter(m => !m.is_surrogate);
                team.matches_played = validMatches.length;
                const totalScore = validMatches.reduce((s, m) => s + m.score, 0);
                const totalAuto = validMatches.reduce((s, m) => s + (m.auto || 0), 0);
                const totalDc = validMatches.reduce((s, m) => s + (m.dc || 0), 0);

                team.avg_score = team.matches_played > 0 ? totalScore / team.matches_played : 0;
                team.avg_auto = team.matches_played > 0 ? totalAuto / team.matches_played : 0;
                team.avg_dc = team.matches_played > 0 ? totalDc / team.matches_played : 0;

                // Breakdown for UI
                const countedIds = new Set([...top10League, ...top5Tourney].map(m => m.match_id));
                team.breakdown = team.matches.sort((a, b) => a.match_id.localeCompare(b.match_id)).map(m => ({
                    ...m,
                    is_counted: countedIds.has(m.match_id)
                }));
            });

            // 4. Sort and Rank
            const ranked = Object.values(AppState.teamsData).sort((a, b) =>
                (b.total_rp - a.total_rp) || (b.avg_score - a.avg_score)
            );

            ranked.forEach((t, i) => {
                t.league_rank = i + 1;
            });

            return ranked;
        }

        function calculateAdvancement() {
            // First ensure rankings are fresh
            const rankedTeams = calculateRankings();

            rankedTeams.forEach(t => {
                // Qual Pts
                t.qual_pts = Math.max(2, 17 - t.league_rank);

                // Awards/Alliance
                t.award_pts = 0;
                t.alliance_pts = 0;
                t.playoff_pts = 0;

                AppState.awards.forEach(a => {
                    if (a.team === t.number) {
                        if (a.award.includes('Alliance')) {
                            // Simplify parsing logic
                            const pts = parseInt(a.award_val); // Stored value
                            if (a.award.includes('Captain')) t.alliance_pts += pts;
                            else if (a.award.includes('Winning') || a.award.includes('Finalist') || a.award.includes('Semi')) t.playoff_pts += pts;
                        } else {
                            t.award_pts += parseInt(a.award_val);
                        }
                    }
                });

                t.advancement_points = t.qual_pts + t.alliance_pts + t.award_pts + t.playoff_pts;
            });

            // Re-sort by Advancement Points
            return rankedTeams.sort((a, b) => b.advancement_points - a.advancement_points);
        }

        /**
         * UI Controller
         */
        const app = {

            async fetchTournamentReal() {
                const icon = document.getElementById('tournament-refresh-icon');
                if (icon) icon.classList.add('animate-spin');

                try {
                    const matches = await fetchMeetData(TOURNAMENT_EVENT.code, TOURNAMENT_EVENT.prefix);

                    // Store tournament matches
                    AppState.tournamentRealMatches = matches || [];

                    // Render in Tournament (Real) tab
                    app.renderTournamentReal();

                    // Auto-populate Tournament (Hypothetical) tab
                    app.populateHypotheticalFromReal();

                    alert(`Loaded ${matches.length} tournament matches!`);
                } catch (e) {
                    console.error(e);
                    alert('Error loading tournament data: ' + e.message);
                } finally {
                    if (icon) icon.classList.remove('animate-spin');
                }
            },

            renderTournamentReal() {
                const tbody = document.getElementById('tournament-real-body');
                if (!tbody) return;

                tbody.innerHTML = '';

                if (!AppState.tournamentRealMatches || AppState.tournamentRealMatches.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="9" class="text-center py-4 text-gray-500">No tournament matches loaded yet. Click "Reload Tournament Data".</td></tr>';
                    return;
                }

                AppState.tournamentRealMatches.forEach(m => {
                    const row = document.createElement('tr');
                    row.className = 'hover:bg-gray-750';
                    row.innerHTML = `
                        <td class="px-3 py-2 font-mono text-gray-400">${m.match_id}</td>
                        <td class="px-3 py-2">${m.red[0] || ''}</td>
                        <td class="px-3 py-2">${m.red[1] || ''}</td>
                        <td class="px-3 py-2 text-center font-bold text-red-400">${m.red_score}</td>
                        <td class="px-3 py-2 text-center">${m.red_rp}</td>
                        <td class="px-3 py-2">${m.blue[0] || ''}</td>
                        <td class="px-3 py-2">${m.blue[1] || ''}</td>
                        <td class="px-3 py-2 text-center font-bold text-blue-400">${m.blue_score}</td>
                        <td class="px-3 py-2 text-center">${m.blue_rp}</td>
                    `;
                    tbody.appendChild(row);
                });
            },

            populateHypotheticalFromReal() {
                if (!AppState.tournamentRealMatches || AppState.tournamentRealMatches.length === 0) return;

                // Clear existing hypothetical matches
                AppState.hypotheticalMatches = [];

                // Populate from real
                AppState.tournamentRealMatches.forEach(m => {
                    const matchNum = m.match_id.replace('TOURN-Q', '');
                    const hypo = {
                        match_id: `Q-${matchNum}`,
                        r1: m.red[0] || '',
                        r2: m.red[1] || '',
                        red_score: m.red_score,
                        red_rp: m.red_rp,
                        red: m.red,
                        b1: m.blue[0] || '',
                        b2: m.blue[1] || '',
                        blue_score: m.blue_score,
                        blue_rp: m.blue_rp,
                        blue: m.blue,
                        match_type: 'TOURNAMENT'
                    };
                    AppState.hypotheticalMatches.push(hypo);

                    // Update UI row
                    const row = document.getElementById(`tmatch-${matchNum}`);
                    if (row) {
                        const inputs = row.querySelectorAll('input');
                        inputs[0].value = hypo.r1; inputs[1].value = hypo.r2;
                        inputs[2].value = hypo.red_score; inputs[3].value = hypo.red_rp;
                        inputs[4].value = hypo.b1; inputs[5].value = hypo.b2;
                        inputs[6].value = hypo.blue_score; inputs[7].value = hypo.blue_rp;
                        app.updateRowUI(row, inputs, matchNum, true);
                    }
                });

                app.saveState();
                app.renderStandings();
            },


            async init() {
                // Load Token
                const token = localStorage.getItem('gh_token');
                if (token) document.getElementById('gh-token').value = token;

                // Load from LocalStorage
                const stored = localStorage.getItem('eb_advancement_state');
                if (stored) {
                    const s = JSON.parse(stored);
                    AppState.hypotheticalMatches = s.hypotheticalMatches || [];
                    AppState.awards = s.awards || [];
                    AppState.teamNotes = s.teamNotes || {};
                    AppState.allianceList = s.allianceList || [];
                    AppState.isHypothetical = s.isHypothetical || false;
                    document.getElementById('mode-toggle').checked = AppState.isHypothetical;
                    app.toggleMode(false); // Update UI only
                    app.updateAwardsList();
                }

                // Init Tournament Rows
                for (let i = 1; i <= 18; i++) app.addTournamentMatchRow(i);

                // Restore match inputs if any
                AppState.hypotheticalMatches.forEach(m => {
                    const num = m.match_id.split('-')[1];
                    const row = document.getElementById(`tmatch-${num}`);
                    if (row) {
                        const inputs = row.querySelectorAll('input');
                        inputs[0].value = m.r1; inputs[1].value = m.r2;
                        inputs[2].value = m.red_score; inputs[3].value = m.red_rp;
                        inputs[4].value = m.b1; inputs[5].value = m.b2;
                        inputs[6].value = m.blue_score; inputs[7].value = m.blue_rp;
                        app.updateRowUI(row, inputs, num, true);
                    }
                });

                // Initial Fetch
                await app.fetchLiveData();
            },

            async fetchLiveData() {
                const btnIcon = document.getElementById('refresh-icon');
                if (btnIcon) btnIcon.classList.add('animate-spin', 'inline-block');
                document.getElementById('data-status').innerHTML = '<span class="w-2 h-2 rounded-full bg-yellow-500 animate-pulse"></span><span>Fetching...</span>';

                try {
                    const allPromises = MEETS.map(m => fetchMeetData(m.code, m.prefix));
                    const results = await Promise.all(allPromises);
                    AppState.matches = results.flat();
                    document.getElementById('data-status').innerHTML = '<span class="w-2 h-2 rounded-full bg-green-500"></span><span>Live Data Ready</span>';
                    app.renderStandings();
                } catch (e) {
                    console.error(e);
                    document.getElementById('data-status').innerHTML = '<span class="w-2 h-2 rounded-full bg-red-500"></span><span>Fetch Error</span>';
                } finally {
                    if (btnIcon) btnIcon.classList.remove('animate-spin', 'inline-block');
                }
            },

            saveState() {
                localStorage.setItem('eb_advancement_state', JSON.stringify({
                    hypotheticalMatches: AppState.hypotheticalMatches,
                    awards: AppState.awards,
                    isHypothetical: AppState.isHypothetical
                }));
            },

            toggleMode(refresh = true) {
                AppState.isHypothetical = document.getElementById('mode-toggle').checked;
                const body = document.body;
                if (AppState.isHypothetical) {
                    body.classList.add('hypothetical-mode-active');
                } else {
                    body.classList.remove('hypothetical-mode-active');
                }
                if (refresh) {
                    app.saveState();
                    app.renderStandings();
                }
            },

            switchTab(tabId) {
                document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
                document.querySelectorAll('.tab-btn').forEach(el => {
                    el.classList.remove('bg-first', 'text-white');
                    el.classList.add('bg-gray-800');
                });

                if (tabId.startsWith('meet')) {
                    document.getElementById('content-meet').classList.remove('hidden');
                    app.renderMeet(tabId);
                    const titles = { 'meet1': 'Meet 1 Results', 'meet2': 'Meet 2 Results', 'meet3': 'Meet 3 Results' };
                    document.getElementById('meet-title').textContent = titles[tabId];
                } else {
                    document.getElementById('content-' + tabId).classList.remove('hidden');
                }

                const btn = document.getElementById('tab-' + tabId);
                btn.classList.remove('bg-gray-800');
                btn.classList.add('bg-first', 'text-white');

                if (tabId === 'standings') app.renderStandings();
                if (tabId === 'advancement') app.renderAdvancement();
                if (tabId === 'alliance') app.renderAlliance();
                if (tabId === 'tournament-real') app.renderTournamentReal();
            },

            renderStandings() {
                const data = calculateRankings();
                const tbody = document.getElementById('standings-body');
                tbody.innerHTML = '';

                // Update Header if not already present (Dynamic check or just assume structure)
                // Ideally I should update the HTML header too, but I can't easily do two non-contiguous edits in one replace_file_content unless I use multi_replace.
                // I will focus on the body content first, and the user can see the column is new.
                // Wait, if I don't update the header, the columns won't align.
                // I should assume the header is static HTML and I need to update it separately or just add the data to an existing column or new badge.
                // Let's add it as a badge next to Total OPR or Name, OR I can try to update the header in a separate call.
                // Actually, I'll update the 'standings-body' generation to include the data, and I'll update the header in a subsequent call.

                // Let's perform the calculation inside the loop
                data.forEach(t => {
                    const isUser = t.number === "14259";
                    const detailId = `detail-${t.number}`;

                    // Prediction Data
                    // Gather valid OPRs
                    const oprs = [];
                    if (t.opr_m1 > 0) oprs.push({ meet: 1, val: t.opr_m1 });
                    if (t.opr_m2 > 0) oprs.push({ meet: 2, val: t.opr_m2 });
                    if (t.opr_m3 > 0) oprs.push({ meet: 3, val: t.opr_m3 });

                    const predictedVal = app.predictNextMeet(oprs);
                    const predDiff = predictedVal - (t.opr_m3 || t.opr_m2 || t.opr_m1 || 0);
                    const trendIcon = predDiff > 5 ? '‚Üó' : (predDiff < -5 ? '‚Üò' : '‚Üí');
                    const trendColor = predDiff > 5 ? 'text-green-400' : (predDiff < -5 ? 'text-red-400' : 'text-gray-400');

                    // Percentile
                    const wOpr = t.tourney_opr || t.opr_m3 || t.opr_m2 || t.opr_m1 || 0;
                    const percentile = app.estimateGlobalPercentile(wOpr);

                    // Simple logic for chart bars
                    const wAuto = (t.oprs.m3.auto || t.oprs.m2.auto || t.oprs.m1.auto || 0);
                    const wDc = (t.oprs.m3.dc || t.oprs.m2.dc || t.oprs.m1.dc || 0);

                    const pAuto = Math.min(100, (wAuto / 60) * 100);
                    const pDc = Math.min(100, (wDc / 100) * 100);
                    const pTotal = Math.min(100, (wOpr / 160) * 100);

                    // Advanced Stats
                    // 1. OPR Map
                    const oprMap = {};
                    data.forEach(tm => oprMap[tm.number] = tm.tourney_opr || tm.opr_m3 || tm.opr_m2 || tm.opr_m1 || 0);

                    // 2. DPR Map (Defensive Power Rating)
                    // We need to solve DPR for all teams once, ideally outside the loop.
                    // But for now, let's solve it if not exists.
                    if (!app.dprResults) {
                        const allTeamNums = data.map(team => team.number);
                        app.dprResults = app.solveDPR(AppState.matches, allTeamNums);
                    }

                    const advStats = app.calculateAdvancedStats(t, AppState.matches, oprMap, app.dprResults);

                    // Format Kryptonite
                    const kryptoniteHtml = advStats.kryptonite.length > 0
                        ? advStats.kryptonite.map(k => `<span class="bg-red-900/50 text-red-300 px-1 rounded text-[10px] border border-red-700/50 mr-1 cursor-help" title="${k.count} Losses">${k.num}</span>`).join('')
                        : '<span class="text-gray-500 text-[10px]">None</span>';

                    // Format Best Friends
                    const friendsHtml = advStats.bestFriends.length > 0
                        ? advStats.bestFriends.map(f => `<span class="bg-indigo-900/50 text-indigo-300 px-1 rounded text-[10px] border border-indigo-700/50 mr-1 cursor-help" title="Avg Score: ${f.avg.toFixed(0)}">${f.num}</span>`).join('')
                        : '<span class="text-gray-500 text-[10px]">None</span>';

                    // Format Shutdowns
                    const shutdownsHtml = advStats.defense.shutdowns.length > 0
                        ? advStats.defense.shutdowns.map(s => `<span class="bg-blue-900/50 text-blue-300 px-1 rounded text-[10px] border border-blue-700/50 mr-1">${s}</span>`).join('')
                        : '<span class="text-gray-500 text-[10px]">None</span>';

                    // Calculate Highest OPR across all meets
                    const allOPRs = [t.opr_m1, t.opr_m2, t.opr_m3, t.tourney_opr].filter(opr => opr > 0);
                    const highestOPR = allOPRs.length > 0 ? Math.max(...allOPRs) : 0;

                    // Calculate per-meet difficulty percentages (relative to league average)
                    const leagueAvgDifficulty = data.reduce((sum, team) => sum + (team.tourney_opr || team.opr_m3 || team.opr_m2 || team.opr_m1 || 0), 0) / data.length;

                    const getDifficultyPercent = (difficulty) => leagueAvgDifficulty > 0 ? (difficulty / leagueAvgDifficulty * 100) : 100;
                    const getDifficultyColor = (percent) => percent > 105 ? 'text-red-400' : percent < 95 ? 'text-green-400' : 'text-gray-400';

                    const diffM1Pct = getDifficultyPercent(advStats.matchDifficulty.m1);
                    const diffM2Pct = getDifficultyPercent(advStats.matchDifficulty.m2);
                    const diffM3Pct = getDifficultyPercent(advStats.matchDifficulty.m3);
                    const diffTournPct = getDifficultyPercent(advStats.matchDifficulty.tournament);

                    tbody.innerHTML += `
                    <tr class="cursor-pointer ${isUser ? 'bg-blue-900/30' : 'hover:bg-gray-700'} border-b border-gray-700 transition" onclick="document.getElementById('${detailId}').classList.toggle('hidden')">
                        <td class="px-6 py-4 font-bold text-center">${t.league_rank}</td>
                        <td class="px-6 py-4 font-mono text-first font-bold">${t.number}</td>
                        <td class="px-6 py-4 text-gray-300 min-w-[150px]">
                            <div>${t.name}</div>
                            <div class="text-[10px] text-gray-500 flex items-center gap-1">
                                <span class="bg-gray-700/50 px-1 rounded text-gray-300" title="Estimated Global Percentile">Top ${(100 - percentile).toFixed(1)}% World</span>
                            </div>
                        </td>
                        <td class="px-6 py-4 text-center text-yellow-400 font-bold">${highestOPR.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center text-indigo-400 font-bold">${predictedVal.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center text-orange-500 font-bold">${t.tourney_opr.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center font-bold text-lg">${t.total_rp}</td>
                        <td class="px-6 py-4 text-center text-gray-400">${t.avg_score.toFixed(1)}</td>
                        <td class="px-6 py-4 text-center text-gray-500">${t.matches_played}</td>
                        <td class="px-6 py-4 text-center text-xs text-gray-500">‚ñº</td>
                    </tr>
                    <tr id="${detailId}" class="hidden bg-gray-900/80 border-b border-gray-700">
                        <td colspan="12" class="p-4">
                            <!-- Advanced Metrics Layout -->
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                
                                <!-- OPR Breakdown Chart -->
                                <div class="bg-gray-800 rounded p-4 border border-gray-700 flex flex-col justify-between">
                                    <div>
                                        <h4 class="font-bold mb-4 text-xs text-indigo-400 uppercase tracking-widest">Performance Profile (Est. OPR)</h4>
                                        
                                        <div class="mb-3">
                                            <div class="flex justify-between text-sm mb-1">
                                                <span class="text-gray-400">Total OPR</span>
                                                <span class="font-bold text-white">${wOpr.toFixed(1)} <span class="text-[10px] text-gray-500">(Top ${(100 - percentile).toFixed(1)}%)</span></span>
                                            </div>
                                            <div class="w-full bg-gray-700 rounded-full h-2">
                                                <div class="bg-indigo-500 h-2 rounded-full" style="width: ${pTotal}%"></div>
                                            </div>
                                        </div>
    
                                        <div class="mb-3">
                                            <div class="flex justify-between text-sm mb-1">
                                                <span class="text-green-400">Auto OPR</span>
                                                <span class="font-bold text-green-300">${wAuto.toFixed(1)}</span>
                                            </div>
                                            <div class="w-full bg-gray-700 rounded-full h-2">
                                                <div class="bg-green-500 h-2 rounded-full" style="width: ${pAuto}%"></div>
                                            </div>
                                        </div>
    
                                        <div class="mb-3">
                                            <div class="flex justify-between text-sm mb-1">
                                                <span class="text-blue-400">Tele/End OPR</span>
                                                <span class="font-bold text-blue-300">${wDc.toFixed(1)}</span>
                                            </div>
                                            <div class="w-full bg-gray-700 rounded-full h-2">
                                                <div class="bg-blue-500 h-2 rounded-full" style="width: ${pDc}%"></div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Scout Metrics -->
                                    <div class="mt-4 pt-4 border-t border-gray-700/50">
                                         <h4 class="font-bold mb-2 text-[10px] text-gray-500 uppercase tracking-widest">Scouting Intel</h4>
                                         <div class="space-y-2">
                                            <div class="flex justify-between text-xs">
                                                <span class="text-gray-400">Contribution</span>
                                                <span class="font-mono ${advStats.contribution > 50 ? 'text-green-400' : 'text-gray-300'}">${advStats.contribution.toFixed(1)}%</span>
                                            </div>
                                            <div class="flex justify-between text-xs">
                                                <span class="text-gray-400">Consistency (¬±)</span>
                                                <span class="font-mono text-gray-300">${advStats.consistency.toFixed(1)} pts</span>
                                            </div>
                                            <div class="flex justify-between text-xs">
                                                <span class="text-gray-400">Strength of Sched.</span>
                                                <span class="font-mono text-gray-300">${advStats.sos.toFixed(0)} Avg OPR</span>
                                            </div>
                                             <div class="flex justify-between text-xs items-center">
                                                <span class="text-gray-400">Kryptonite (Losses)</span>
                                                <div class="text-right">${kryptoniteHtml}</div>
                                            </div>
                                            <!-- Defense & Chemistry -->
                                            <div class="flex justify-between text-xs items-center mt-2 pt-2 border-t border-gray-700/30">
                                                <span class="text-indigo-400">Best Friends</span>
                                                <div class="text-right">${friendsHtml}</div>
                                            </div>
                                            <div class="flex justify-between text-xs items-center">
                                                <span class="text-blue-400" title="Defensive Power Rating (Pts Allowed)">Defense (DPR)</span>
                                                <span class="font-mono text-gray-300">${advStats.defense.dpr.toFixed(1)} pts</span>
                                            </div>
                                            <div class="flex justify-between text-xs items-center">
                                                <span class="text-gray-500">Shutdowns</span>
                                                <div class="text-right">${shutdownsHtml}</div>
                                            </div>
                                            <!-- Match Difficulty -->
                                            <div class="mt-2 pt-2 border-t border-gray-700/30">
                                                <div class="text-[10px] text-gray-500 uppercase mb-1">Match Difficulty</div>
                                                <div class="flex justify-between text-xs">
                                                    <span class="text-yellow-600">M1: ${advStats.matchDifficulty.m1.toFixed(0)}</span>
                                                    <span class="font-mono font-bold ${getDifficultyColor(diffM1Pct)}" title="Relative to league average">${diffM1Pct.toFixed(0)}%</span>
                                                </div>
                                                <div class="flex justify-between text-xs">
                                                    <span class="text-yellow-500">M2: ${advStats.matchDifficulty.m2.toFixed(0)}</span>
                                                    <span class="font-mono font-bold ${getDifficultyColor(diffM2Pct)}" title="Relative to league average">${diffM2Pct.toFixed(0)}%</span>
                                                </div>
                                                <div class="flex justify-between text-xs">
                                                    <span class="text-yellow-400">M3: ${advStats.matchDifficulty.m3.toFixed(0)}</span>
                                                    <span class="font-mono font-bold ${getDifficultyColor(diffM3Pct)}" title="Relative to league average">${diffM3Pct.toFixed(0)}%</span>
                                                </div>
                                                <div class="flex justify-between text-xs">
                                                    <span class="text-orange-400">Tourn: ${advStats.matchDifficulty.tournament.toFixed(0)}</span>
                                                    <span class="font-mono font-bold ${getDifficultyColor(diffTournPct)}" title="Relative to league average">${diffTournPct.toFixed(0)}%</span>
                                                </div>
                                            </div>
                                         </div>
                                    </div>
                                </div>

                                <!-- Average Scores & Match History -->
                                <div class="bg-gray-800 rounded p-4 border border-gray-700 col-span-2 flex flex-col">
                                    <div class="grid grid-cols-4 gap-4 text-center mb-4">
                                        <div class="p-2 bg-gray-750 rounded relative group">
                                            <div class="text-[10px] text-gray-400 uppercase">Avg Score</div>
                                            <div class="text-xl font-bold text-white">${t.avg_score.toFixed(1)}</div>
                                            
                                        </div>
                                        <div class="p-2 bg-gray-750 rounded">
                                            <div class="text-[10px] text-green-400 uppercase">Avg Auto</div>
                                            <div class="text-lg font-bold text-white">${t.avg_auto.toFixed(1)}</div>
                                        </div>
                                        <div class="p-2 bg-gray-750 rounded">
                                            <div class="text-[10px] text-blue-400 uppercase">Avg Tele/End</div>
                                            <div class="text-lg font-bold text-white">${t.avg_dc.toFixed(1)}</div>
                                        </div>
    
                                         <div class="p-2 bg-gray-750 rounded border border-gray-700/50">
                                            <div class="text-[10px] text-indigo-400 uppercase">Pred. Tourn</div>
                                            <div class="text-lg font-bold ${trendColor}">${predictedVal.toFixed(1)} <span class="text-xs">${trendIcon}</span></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Meet OPRs -->
                                    <div class="mb-3 p-2 bg-gray-750 rounded border border-gray-700/50">
                                        <div class="text-[10px] text-gray-400 uppercase mb-1 font-bold">Meet OPRs</div>
                                        <div class="flex justify-between items-center text-xs">
                                            <span class="text-yellow-600">M1:</span>
                                            <span class="font-mono text-white">${t.opr_m1.toFixed(1)}</span>
                                        </div>
                                        <div class="flex justify-between items-center text-xs">
                                            <span class="text-yellow-500">M2:</span>
                                            <span class="font-mono text-white">${t.opr_m2.toFixed(1)}</span>
                                        </div>
                                        <div class="flex justify-between items-center text-xs">
                                            <span class="text-yellow-400">M3:</span>
                                            <span class="font-mono text-white">${t.opr_m3.toFixed(1)}</span>
                                        </div>
                                    </div>
                                    
                                    <!-- Trend Graph -->
                                    <div class="mb-4 h-24 w-full bg-gray-900 rounded relative border border-gray-700/50">
                                        <div class="absolute top-2 left-2 text-[10px] text-gray-500 uppercase font-bold tracking-wider z-10">Score Trend</div>
                                        ${app.generateSparkline(t.matches.filter(m => !m.is_surrogate).sort((a, b) => a.match_id.localeCompare(b.match_id)))}
                                    </div>

                                    <div class="overflow-x-auto flex-grow max-h-40 overflow-y-auto">
                                        <table class="w-full text-xs text-left">
                                            <thead class="text-gray-500 border-b border-gray-700 sticky top-0 bg-gray-800">
                                                <tr>
                                                    <th class="py-1 pl-2">Match</th>
                                                    <th class="py-1">Alliance</th>
                                                    <th class="py-1 text-right">Auto</th>
                                                    <th class="py-1 text-right">Tele/End</th>
                                                    <th class="py-1 text-right">Total</th>
                                                    <th class="py-1 text-center">RP</th>
                                                </tr>
                                            </thead>
                                            <tbody class="text-gray-300">
                                                ${app.getMatchRowsForTeam(t.number)}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Notes -->
                            <div class="mt-3 bg-gray-800 rounded p-4 border border-gray-700 flex flex-col">
                                <h4 class="font-bold mb-2 text-xs text-yellow-400 uppercase tracking-widest">Team Notes (Shared)</h4>
                                <textarea 
                                    class="w-full bg-gray-700 text-white rounded p-3 text-sm flex-grow border border-gray-600 focus:border-yellow-500 focus:outline-none transition"
                                    rows="1" 
                                    placeholder="Add notes (e.g. Robot reliability, auto paths)..."
                                    onchange="app.saveTeamNote('${t.number}', this.value)"
                                >${AppState.teamNotes[t.number] || ''}</textarea>
                            </div>
                        </td>
                    </tr>
                 `;
                });
            },

            renderMeet(tabId) {
                const prefix = tabId === 'meet1' ? 'M1' : (tabId === 'meet2' ? 'M2' : 'M3');
                const matches = AppState.matches.filter(m => m.match_id.startsWith(prefix));
                const tbody = document.getElementById('meet-body');
                tbody.innerHTML = '';

                // Calculate OPRs based on what was available before this meet
                // For M1: use default/initial OPR estimates (we'll use 0 or league avg)
                // For M2: use M1 OPR data
                // For M3: use M1+M2 OPR data
                let allPreviousMatches = [];
                if (prefix === 'M2') {
                    allPreviousMatches = AppState.matches.filter(m => m.match_id.startsWith('M1'));
                } else if (prefix === 'M3') {
                    allPreviousMatches = AppState.matches.filter(m => m.match_id.startsWith('M1') || m.match_id.startsWith('M2'));
                }

                const allTeamNumbers = [...new Set(matches.flatMap(m => [...m.red, ...m.blue]))];
                const oprData = allPreviousMatches.length > 0 ? solveOPR(allPreviousMatches, allTeamNumbers) : {};

                // Helper function to calculate win probability
                const calculateWinProb = (redTeams, blueTeams) => {
                    const redOPR = redTeams.reduce((sum, team) => sum + (oprData[team] || 35), 0); // Default 35 if no data
                    const blueOPR = blueTeams.reduce((sum, team) => sum + (oprData[team] || 35), 0);
                    const totalOPR = redOPR + blueOPR;
                    return totalOPR > 0 ? (redOPR / totalOPR * 100) : 50;
                };

                // Helper to color-code probability
                const getWinProbColor = (prob) => {
                    if (prob > 60) return 'text-green-400';
                    if (prob < 40) return 'text-red-400';
                    return 'text-gray-400';
                };

                matches.forEach(m => {
                    const winProb = calculateWinProb(m.red, m.blue);
                    tbody.innerHTML += `
                    <tr class="hover:bg-gray-750">
                        <td class="px-4 py-2 font-mono text-gray-400">${m.match_id}</td>
                        <td class="px-4 py-2 text-right">${m.red.join(', ')}</td>
                        <td class="px-4 py-2 text-center font-bold ${getWinProbColor(winProb)}">${winProb.toFixed(0)}%</td>
                        <td class="px-4 py-2 text-center font-bold text-red-400">${m.red_score}</td>
                        <td class="px-4 py-2 text-center font-bold text-blue-400">${m.blue_score}</td>
                        <td class="px-4 py-2 text-left">${m.blue.join(', ')}</td>
                        <td class="px-4 py-2 text-center">${m.red_rp}</td>
                        <td class="px-4 py-2 text-center">${m.blue_rp}</td>
                    </tr>`;
                });
            },

            addTournamentMatchRow(num) {
                const tbody = document.getElementById('tournament-table-body');
                const row = document.createElement('tr');
                row.id = `tmatch-${num}`;
                row.className = 'bg-gray-700';
                row.innerHTML = `
                <td class="px-3 py-2">Q-${num}</td>
                <td class="px-3 py-2"><input type="text" list="team-numbers" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-base" placeholder="R1"></td>
                <td class="px-3 py-2"><input type="text" list="team-numbers" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-base" placeholder="R2"></td>
                <td class="px-3 py-2"><input type="number" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-center text-base" placeholder="Score"></td>
                <td class="px-3 py-2"><input type="number" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-center text-base" placeholder="RP"></td>
                <td class="px-3 py-2"><input type="text" list="team-numbers" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-base" placeholder="B1"></td>
                <td class="px-3 py-2"><input type="text" list="team-numbers" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-base" placeholder="B2"></td>
                <td class="px-3 py-2"><input type="number" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-center text-base" placeholder="Score"></td>
                <td class="px-3 py-2"><input type="number" class="w-full bg-gray-600 rounded px-2 py-1 text-sm text-center text-base" placeholder="RP"></td>
                <td class="px-3 py-2 flex gap-1">
                    <button onclick="app.saveTournamentMatch(${num})" class="bg-green-600 text-white px-2 py-1 rounded text-xs">Save</button>
                    <button onclick="app.clearTournamentMatch(${num})" class="bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded text-xs" title="Reset match">‚úï</button>
                </td>
            `;
                tbody.appendChild(row);
            },

            saveTournamentMatch(num) {
                const row = document.getElementById(`tmatch-${num}`);
                const i = row.querySelectorAll('input');
                const match = {
                    match_id: `Q-${num}`,
                    r1: i[0].value, r2: i[1].value, red_score: parseInt(i[2].value || 0), red_rp: parseInt(i[3].value || 0), red: [i[0].value, i[1].value],
                    b1: i[4].value, b2: i[5].value, blue_score: parseInt(i[6].value || 0), blue_rp: parseInt(i[7].value || 0), blue: [i[4].value, i[5].value],
                    match_type: "TOURNAMENT"
                };

                // Upsert
                AppState.hypotheticalMatches = AppState.hypotheticalMatches.filter(m => m.match_id !== match.match_id);
                AppState.hypotheticalMatches.push(match);
                app.saveState();
                app.updateRowUI(row, i, num, true);

                // Auto-enable Hypothetical Mode if forced
                if (!AppState.isHypothetical) {
                    document.getElementById('mode-toggle').checked = true;
                    app.toggleMode(false); // Enable without re-render loop
                }
                app.renderStandings(); // Re-render to update OPR
            },

            clearTournamentMatch(num) {
                // 1. Remove from State
                const matchId = `Q-${num}`;
                AppState.hypotheticalMatches = AppState.hypotheticalMatches.filter(m => m.match_id !== matchId);
                app.saveState();

                // 2. Clear Inputs
                const row = document.getElementById(`tmatch-${num}`);
                const inputs = row.querySelectorAll('input');
                inputs.forEach(i => i.value = '');

                // 3. Reset UI
                row.classList.remove('bg-yellow-900/40');
                row.classList.add('bg-gray-700');

                // 4. Update Rankings
                app.renderStandings();
                app.renderAdvancement(); app.renderAlliance();
            },

            updateRowUI(row, inputs, num, saved) {
                if (saved) {
                    row.classList.remove('bg-gray-700');
                    row.classList.add('bg-yellow-900/40'); // Always yellow as it's hypothetical/local
                }
            },

            addAdvancement() {
                const t = document.getElementById('adv_team').value;
                const sel = document.getElementById('adv_type');
                const label = sel.options[sel.selectedIndex].text;
                const val = sel.value;
                // Allow adding 0 value awards if needed, checking explicitly for null/undefined if that was the intent,
                // but here just checking team existence
                if (!t) return;

                // Check for duplicate award
                const duplicate = AppState.awards.find(a => a.team === t && a.award === label);
                if (duplicate) {
                    alert(`Team ${t} already has award: ${label}\n\nPlease remove the existing award first if you want to update it.`);
                    return;
                }

                AppState.awards.push({ team: t, award: label, award_val: val });
                app.saveState();
                app.updateAwardsList();
                app.renderAdvancement(); app.renderAlliance();
                document.getElementById('adv_team').value = '';
            },


            updateAwardsList() {
                const div = document.getElementById('awards-list');
                div.innerHTML = AppState.awards.map((a, i) => `
                <div class="bg-gray-700 p-2 rounded flex justify-between">
                    <span><b>${a.team}</b>: ${a.award}</span>
                    <button onclick="app.removeAward(${i})" class="text-red-500">‚úï</button>
                </div>
            `).join('');
            },

            saveTeamNote(teamNum, note) {
                if (!AppState.teamNotes) AppState.teamNotes = {};
                AppState.teamNotes[teamNum] = note;
                app.saveState();
            },



            // ALLIANCE FUNCTIONS
            addToAlliance(teamNum) {
                if (!AppState.allianceList) AppState.allianceList = [];
                if (!AppState.allianceList.includes(teamNum)) {
                    AppState.allianceList.push(teamNum);
                    app.saveState();
                    app.renderAlliance();
                }
            },

            removeFromAlliance(teamNum) {
                AppState.allianceList = AppState.allianceList.filter(t => t !== teamNum);
                app.saveState();
                app.renderAlliance();
            },

            moveAllianceItem(index, direction) {
                const list = AppState.allianceList;
                if (direction === -1 && index > 0) {
                    [list[index], list[index - 1]] = [list[index - 1], list[index]];
                } else if (direction === 1 && index < list.length - 1) {
                    [list[index], list[index + 1]] = [list[index + 1], list[index]];
                }
                app.saveState();
                app.renderAlliance();
            },

            renderAlliance() {
                const search = (document.getElementById('alliance-search')?.value || '').toLowerCase();
                const availableDiv = document.getElementById('alliance-available');
                const selectedDiv = document.getElementById('alliance-selected');

                if (!availableDiv || !selectedDiv) return;

                // Render Available
                const selectedSet = new Set(AppState.allianceList || []);
                const allTeams = calculateRankings(); // Get stats for display

                const filteredTeams = allTeams.filter(t => !selectedSet.has(t.number) && (t.number.includes(search) || t.name.toLowerCase().includes(search)));

                if (filteredTeams.length === 0) {
                    availableDiv.innerHTML = '<div class="text-gray-500 text-center italic p-4">No teams found. Try refreshing matches.</div>';
                } else {
                    availableDiv.innerHTML = filteredTeams.map(t => `
                        <div class="bg-gray-700 p-3 rounded flex justify-between items-center hover:bg-gray-600 cursor-pointer transition"
                             onclick="app.addToAlliance('${t.number}')">
                            <div class="flex flex-col">
                                <span class="font-bold text-white">${t.number} <span class="font-normal text-gray-400 text-sm">- ${t.name}</span></span>
                                <div class="text-xs text-gray-300 mt-1 flex space-x-3">
                                    <span>Rank: <b class="text-white">${t.league_rank}</b></span>
                                    <span>NP-OPR: <b class="text-yellow-400">${Math.max(t.opr_m1, t.opr_m2, t.opr_m3).toFixed(0)}</b></span>
                                    <span>T-OPR: <b class="text-orange-400">${t.tourney_opr.toFixed(0)}</b></span>
                                </div>
                            </div>
                            <button class="text-green-400 font-bold hover:text-green-300 text-xl">+</button>
                        </div>
                    `).join('');
                }

                // Render Selected (Draggable)
                selectedDiv.innerHTML = (AppState.allianceList || []).map((teamNum, i) => {
                    const t = allTeams.find(x => x.number === teamNum) || { number: teamNum, name: 'Unknown', opr_m3: 0, tourney_opr: 0 };
                    return `
                        <div class="bg-gray-700 p-3 rounded flex justify-between items-center group relative border-l-4 border-yellow-500" draggable="true"
                             ondragstart="app.dragStart(event, ${i})" ondragover="app.dragOver(event)" ondrop="app.drop(event, ${i})">
                            <div class="flex items-center space-x-3">
                                <span class="text-gray-500 font-mono text-xs w-4">${i + 1}</span>
                                <div>
                                    <div class="font-bold text-white">${t.number}</div>
                                    <div class="text-xs text-gray-400">${t.name}</div>
                                </div>
                            </div>
                             <div class="text-xs text-gray-300 flex space-x-2">
                                <span>OPR: ${t.opr_m3?.toFixed(0)}</span>
                             </div>
                            <div class="flex items-center space-x-1">
                                <button onclick="app.moveAllianceItem(${i}, -1)" class="p-1 text-gray-400 hover:text-white">‚ñ≤</button>
                                <button onclick="app.moveAllianceItem(${i}, 1)" class="p-1 text-gray-400 hover:text-white">‚ñº</button>
                                <button onclick="app.removeFromAlliance('${t.number}')" class="p-1 text-red-500 hover:text-red-400 ml-2">‚úï</button>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            dragStart(e, index) { e.dataTransfer.setData('text/plain', index); },
            dragOver(e) { e.preventDefault(); },
            drop(e, targetIndex) {
                e.preventDefault();
                const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
                if (sourceIndex !== targetIndex) {
                    const list = AppState.allianceList;
                    const item = list.splice(sourceIndex, 1)[0];
                    list.splice(targetIndex, 0, item);
                    app.saveState();
                    app.renderAlliance();
                }
            },

            removeAward(i) {
                AppState.awards.splice(i, 1);
                app.saveState();
                app.updateAwardsList();
                app.renderAdvancement();
                app.renderAlliance();
            },

            renderAdvancement() {
                const data = calculateAdvancement();
                const tbody = document.getElementById('advancement-body');
                tbody.innerHTML = '';
                data.forEach((t, i) => {
                    const bg = i < 2 ? 'bg-green-900/30 border-l-4 border-green-500' : (t.number === '14259' ? 'bg-blue-900/30' : '');
                    tbody.innerHTML += `
                    <tr class="${bg}">
                        <td class="px-4 py-3 font-bold whitespace-nowrap">${t.league_rank}</td>
                         <td class="px-4 py-3 font-mono whitespace-nowrap">${t.number}</td>
                        <td class="px-4 py-3 text-center text-gray-400 whitespace-nowrap">${t.qual_pts}</td>
                        <td class="px-4 py-3 text-center text-gray-400 whitespace-nowrap">${t.alliance_pts}</td>
                        <td class="px-4 py-3 text-center text-gray-400 whitespace-nowrap">${t.award_pts}</td>
                        <td class="px-4 py-3 text-center text-gray-400 whitespace-nowrap">${t.playoff_pts}</td>
                        <td class="px-4 py-3 text-center font-bold text-white text-lg whitespace-nowrap">${t.advancement_points}</td>
                    </tr>
                `;
                });
            },

            renderHighestOPR() {
                const data = calculateRankings();
                // Sort by tournament OPR (descending)
                const sorted = [...data].sort((a, b) => b.tourney_opr - a.tourney_opr);

                const tbody = document.getElementById('highest-opr-body');
                tbody.innerHTML = '';

                sorted.forEach((t, i) => {
                    const isUser = t.number === '14259';
                    const predictedVal = t.predicted_tourney_opr || t.tourney_opr;

                    tbody.innerHTML += `
                    <tr class="${isUser ? 'bg-blue-900/30' : 'hover:bg-gray-700'} border-b border-gray-700 transition">
                        <td class="px-6 py-4 font-bold text-center">${i + 1}</td>
                        <td class="px-6 py-4 font-mono text-first font-bold">${t.number}</td>
                        <td class="px-6 py-4 text-gray-300">${t.name}</td>
                        <td class="px-6 py-4 text-center text-orange-500 font-bold">${t.tourney_opr.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center text-indigo-400 font-bold">${predictedVal.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center text-green-400">${t.opr_auto.toFixed(0)}</td>
                        <td class="px-6 py-4 text-center text-blue-400">${t.opr_dc.toFixed(0)}</td>
                    </tr>
                `;
                });
            },

            resetAll() {
                // Show custom modal
                const modal = document.getElementById('confirm-modal');
                const cloudOption = document.getElementById('cloud-wipe-option');
                const checkbox = document.getElementById('wipe-cloud-checkbox');

                modal.classList.remove('hidden');
                modal.classList.add('flex');

                // Only show cloud wipe option if firebase is enabled
                if (firebaseEnabled) {
                    cloudOption.classList.remove('hidden');
                    checkbox.checked = false;
                } else {
                    cloudOption.classList.add('hidden');
                }
            },

            async executeClearAll() {
                const wipeCloud = document.getElementById('wipe-cloud-checkbox').checked;
                document.getElementById('confirm-modal').classList.add('hidden'); // Close modal

                // Clear local state
                AppState.hypotheticalMatches = [];
                AppState.awards = [];
                AppState.teamNotes = {};
                AppState.allianceList = [];
                AppState.tournamentRealMatches = [];

                // Handle cloud data
                if (firebaseEnabled && wipeCloud) {
                    app.setCloudStatus('Wiping cloud data...', 'text-red-400');
                    try {
                        await app.clearCloudData();
                        alert('All data (Local + Cloud) has been wiped.');
                        location.reload();
                    } catch (e) {
                        alert('Error wiping cloud data: ' + e.message);
                        location.reload();
                    }
                } else {
                    // Just clear local and reload
                    localStorage.removeItem('app_state');
                    location.reload();
                }
            },





            forceSyncToCloud() {
                if (!firebaseEnabled) {
                    app.setCloudStatus('Firebase not configured - check console', 'text-yellow-500');
                    setTimeout(() => app.setCloudStatus('', ''), 3000);
                    return;
                }

                app.setCloudStatus('Saving to cloud...', 'text-yellow-400');

                // Safety timeout - clear status after 10 seconds if something goes wrong
                const timeoutId = setTimeout(() => {
                    app.setCloudStatus('Sync timeout - please refresh', 'text-red-500');
                    setTimeout(() => app.setCloudStatus('', ''), 3000);
                }, 10000);

                const data = {
                    hypotheticalMatches: AppState.hypotheticalMatches,
                    awards: AppState.awards,
                    teamNotes: AppState.teamNotes,
                    allianceList: AppState.allianceList,
                    isHypothetical: AppState.isHypothetical,
                    tournamentRealMatches: AppState.tournamentRealMatches || [],
                    timestamp: new Date().toISOString()
                };

                database.ref('eb_advancement_state').set(data)
                    .then(() => {
                        clearTimeout(timeoutId);
                        app.setCloudStatus('Saved to cloud! ‚úì', 'text-green-500');
                        document.getElementById('last-sync-time').textContent = new Date().toLocaleTimeString();
                        setTimeout(() => app.setCloudStatus('', ''), 2000);
                    })
                    .catch(e => {
                        clearTimeout(timeoutId);
                        console.error(e);
                        app.setCloudStatus('Error: ' + e.message, 'text-red-500');
                        setTimeout(() => app.setCloudStatus('', ''), 5000);
                    });
            },


            forceSyncFromCloud() {
                if (!firebaseEnabled) {
                    app.setCloudStatus('Firebase not configured - check console', 'text-yellow-500');
                    return;
                }

                app.setCloudStatus('Loading from cloud...', 'text-yellow-400');

                database.ref('eb_advancement_state').once('value')
                    .then(snapshot => {
                        const data = snapshot.val();
                        if (!data) {
                            app.setCloudStatus('No cloud data found', 'text-gray-400');
                            return;
                        }

                        // Clear current
                        AppState.hypotheticalMatches = [];
                        AppState.awards = [];
                        AppState.teamNotes = {};
                        AppState.allianceList = [];
                        AppState.tournamentRealMatches = [];
                        document.querySelectorAll("input[type=text], input[type=number]").forEach(i => i.value = "");
                        document.querySelectorAll("[id^=tmatch-]").forEach(r => {
                            r.classList.remove("bg-yellow-900/40");
                            r.classList.add("bg-gray-700");
                        });

                        // Load cloud data
                        AppState.hypotheticalMatches = data.hypotheticalMatches || [];
                        AppState.awards = data.awards || [];
                        AppState.teamNotes = data.teamNotes || {};
                        AppState.allianceList = data.allianceList || [];
                        AppState.tournamentRealMatches = data.tournamentRealMatches || [];
                        AppState.isHypothetical = data.isHypothetical || false;
                        app.saveState();

                        document.getElementById("mode-toggle").checked = AppState.isHypothetical;
                        if (AppState.isHypothetical) document.body.classList.add("hypothetical-mode-active");
                        else document.body.classList.remove("hypothetical-mode-active");

                        // Restore matches
                        AppState.hypotheticalMatches.forEach(m => {
                            const num = m.match_id.split("-")[1];
                            const row = document.getElementById(`tmatch-${num}`);
                            if (row) {
                                const inputs = row.querySelectorAll("input");
                                inputs[0].value = m.r1; inputs[1].value = m.r2;
                                inputs[2].value = m.red_score; inputs[3].value = m.red_rp;
                                inputs[4].value = m.b1; inputs[5].value = m.b2;
                                inputs[6].value = m.blue_score; inputs[7].value = m.blue_rp;
                                app.updateRowUI(row, inputs, num, true);
                            }
                        });


                        app.updateAwardsList();
                        app.renderStandings();
                        app.renderAdvancement();
                        app.renderAlliance();
                        app.renderTournamentReal();

                        app.setCloudStatus('Loaded from cloud! ‚úì', 'text-green-500');
                        document.getElementById('last-sync-time').textContent = new Date().toLocaleTimeString();
                        setTimeout(() => app.setCloudStatus('', ''), 2000);
                    })
                    .catch(e => {
                        console.error(e);
                        app.setCloudStatus('Error: ' + e.message, 'text-red-500');
                    });
            },

            // --- Advanced Stats Helpers ---

            predictNextMeet(oprs) {
                // Linear Regression on available data points
                // oprs = [{meet: 1, val: 10}, {meet: 2, val: 15}, ...]
                // Filters out zeros or missing meets if necessary, but ideally uses all 3 if present
                const points = oprs.filter(p => p.val > 0);
                if (points.length < 2) return points.length > 0 ? points[0].val : 0; // Not enough data for trend

                const n = points.length;
                const sumX = points.reduce((a, p) => a + p.meet, 0);
                const sumY = points.reduce((a, p) => a + p.val, 0);
                const sumXY = points.reduce((a, p) => a + (p.meet * p.val), 0);
                const sumXX = points.reduce((a, p) => a + (p.meet * p.meet), 0);

                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                // Predict for Meet 4 (Tournament)
                // If we treat M1=1, M2=2, M3=3, Tourn=4
                const predicted = slope * 4 + intercept;
                return Math.max(0, predicted); // No negative OPR
            },

            estimateGlobalPercentile(opr) {
                // ESTIMATION for Into The Deep 2025
                // Mean ~45, StdDev ~20 based on early season data
                const mean = 45;
                const stdDev = 20;

                const z = (opr - mean) / stdDev;

                // Approximation of CDF for Normal Distribution
                // Using error function approximation
                const t = 1 / (1 + 0.2316419 * Math.abs(z));
                const d = 0.3989423 * Math.exp(-z * z / 2);
                let p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));

                if (z > 0) p = 1 - p;

                return Math.min(99.9, Math.max(0.1, p * 100));
            },

            async clearCloudData() {
                if (!confirm("DANGER: This will wipe cloud data for everyone!")) return;

                if (!firebaseEnabled) {
                    localStorage.clear();
                    location.reload();
                    return;
                }

                app.setCloudStatus('Clearing cloud...', 'text-yellow-400');

                database.ref('eb_advancement_state').remove()
                    .then(() => {
                        app.setCloudStatus('Cloud cleared! ‚úì', 'text-green-500');
                        localStorage.clear();
                        setTimeout(() => location.reload(), 1000);
                    })
                    .catch(e => {
                        console.error(e);
                        app.setCloudStatus('Error: ' + e.message, 'text-red-500');
                    });
            },





            // --- New Advanced Metrics Helpers ---

            solveDPR(matches, teamNumbers) {
                // To solve DPR (Defensive Power Rating), we solve OPR but swap scores.
                // Red Score becomes Blue Score (points allowed).
                // Blue Score becomes Red Score (points allowed).
                const dpMatches = matches.map(m => ({
                    ...m,
                    red_score: m.blue_score, // Red allow Blue's score
                    blue_score: m.red_score, // Blue allow Red's score
                    red_score_np: m.blue_score,
                    blue_score_np: m.red_score
                }));
                return solveOPR(dpMatches, teamNumbers);
            },

            getStandardDeviation(array) {
                if (!array || array.length === 0) return 0;
                const n = array.length;
                const mean = array.reduce((a, b) => a + b, 0) / n;
                const variance = array.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
                return Math.sqrt(variance);
            },

            calculateAdvancedStats(team, allMatches, oprResults, dprResults) {
                // Filter matches played by this team
                const teamMatches = allMatches.filter(m => m.red.includes(team.number) || m.blue.includes(team.number));
                if (teamMatches.length === 0) return {
                    consistency: 0,
                    contribution: 0,
                    sos: 0,
                    kryptonite: [],
                    bestFriends: [],
                    defense: { dpr: 0, impact: 0, shutdowns: [] },
                    matchDifficulty: { m1: 0, m2: 0, m3: 0, tournament: 0 }
                };

                // 1. Consistency (Std Dev of Score)
                const scores = teamMatches.map(m => m.red.includes(team.number) ? m.red_score : m.blue_score);
                const consistency = app.getStandardDeviation(scores);

                // 2. Contribution % (OPR / Avg Alliance Score)
                const avgAllianceScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                const contribution = (team.tourney_opr || team.opr_m3 || team.opr_m2 || team.opr_m1 || 0) / (avgAllianceScore || 1) * 100;

                // 3. SOS, Kryptonite, Best Friends, Shutdowns
                let opponentOprSum = 0;
                let opponentCount = 0;

                const lossesTo = {}; // { teamNum: count }
                const partnerScores = {}; // { teamNum: [scores] }
                let lowestAllowed = { score: 999, opp: [] }; // Shutdowns

                teamMatches.forEach(m => {
                    const isRed = m.red.includes(team.number);
                    const opponents = isRed ? m.blue : m.red;
                    const partners = isRed ? m.red : m.blue;
                    const myScore = isRed ? m.red_score : m.blue_score;
                    const oppScore = isRed ? m.blue_score : m.red_score;

                    const result = myScore > oppScore ? 'W' : (myScore < oppScore ? 'L' : 'T');

                    // SOS & Kryptonite & Shutdowns
                    opponents.forEach(opp => {
                        const oppOpr = oprResults[opp] || 0;
                        if (oppOpr > 0) {
                            opponentOprSum += oppOpr;
                            opponentCount++;
                        }
                        if (result === 'L') lossesTo[opp] = (lossesTo[opp] || 0) + 1;
                    });

                    // Track Shutdowns (lowest opponent score)
                    if (oppScore < lowestAllowed.score) {
                        lowestAllowed.score = oppScore;
                        lowestAllowed.opp = opponents;
                    } else if (oppScore === lowestAllowed.score) {
                        lowestAllowed.opp = [...lowestAllowed.opp, ...opponents];
                    }

                    // Best Friends (Partners)
                    partners.forEach(p => {
                        if (p !== team.number) {
                            if (!partnerScores[p]) partnerScores[p] = [];
                            partnerScores[p].push(myScore);
                        }
                    });
                });

                const sos = opponentCount > 0 ? opponentOprSum / opponentCount : 0;

                // Sort Kryptonite
                const kryptonite = Object.entries(lossesTo)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([num, count]) => ({ num, count }));

                // Sort Best Friends (Avg Score)
                const bestFriends = Object.entries(partnerScores)
                    .map(([num, scores]) => ({ num, avg: scores.reduce((a, b) => a + b, 0) / scores.length, count: scores.length }))
                    .sort((a, b) => b.avg - a.avg)
                    .slice(0, 3); // Top 3

                // Defense
                const dpr = dprResults ? (dprResults[team.number] || 0) : 0;
                // Impact: Measure against global avg score (e.g., 45ish)
                // Positive impact = lower DPR than avg
                const globalAvgScore = 45; // Approx for Into The Deep
                const defenseImpact = globalAvgScore - dpr; // Positive means good defense (low DPR)

                // Match Difficulty by Meet
                const matchDifficulty = app.calculateMatchDifficulty(team.number, allMatches);

                return {
                    consistency,
                    contribution,
                    sos,
                    kryptonite,
                    bestFriends,
                    defense: { dpr, impact: defenseImpact, shutdowns: [...new Set(lowestAllowed.opp)].slice(0, 3), minAllowed: lowestAllowed.score },
                    matchDifficulty // { m1: avg, m2: avg, m3: avg, tournament: avg }
                };
            },

            calculateMatchDifficulty(teamNum, allMatches) {
                // Calculate OPRs for each meet
                const m1Matches = allMatches.filter(m => m.match_id.includes('M1-'));
                const m2Matches = allMatches.filter(m => m.match_id.includes('M2-'));
                const m3Matches = allMatches.filter(m => m.match_id.includes('M3-'));
                const tournamentMatches = allMatches.filter(m => !m.match_id.includes('M1-') && !m.match_id.includes('M2-') && !m.match_id.includes('M3-'));

                // Extract all team numbers from matches
                const allTeamNumbers = [...new Set(allMatches.flatMap(m => [...(m.red || []), ...(m.blue || [])]))].filter(t => t);

                const m1OPR = solveOPR(m1Matches, allTeamNumbers);
                const m2OPR = solveOPR(m1Matches.concat(m2Matches), allTeamNumbers);
                const m3OPR = solveOPR(m1Matches.concat(m2Matches, m3Matches), allTeamNumbers);

                // Helper to calculate avg opponent OPR for a set of matches
                const getAvgOpponentOPR = (matches, oprMap) => {
                    const teamMatches = matches.filter(m => (m.red || []).includes(teamNum) || (m.blue || []).includes(teamNum));
                    if (teamMatches.length === 0) return 0;

                    let totalOPR = 0;
                    let count = 0;

                    teamMatches.forEach(m => {
                        const isRed = (m.red || []).includes(teamNum);
                        const opponents = isRed ? (m.blue || []) : (m.red || []);

                        opponents.forEach(opp => {
                            const oppOPR = oprMap[opp] || 0;
                            if (oppOPR > 0) {
                                totalOPR += oppOPR;
                                count++;
                            }
                        });
                    });

                    return count > 0 ? totalOPR / count : 0;
                };

                return {
                    m1: getAvgOpponentOPR(m1Matches, m1OPR), // Use M1 OPR for M1 difficulty
                    m2: getAvgOpponentOPR(m2Matches, m1OPR), // Use M1 OPR for M2 difficulty (what was known before M2)
                    m3: getAvgOpponentOPR(m3Matches, m2OPR), // Use M2 OPR for M3 difficulty (what was known before M3)
                    tournament: getAvgOpponentOPR(tournamentMatches, m3OPR) // Use M3 OPR for tournament (or could use predicted)
                };
            },

            getMatchRowsForTeam(teamNum) {
                const allTeamMatches = AppState.matches.filter(m => m.red.includes(teamNum) || m.blue.includes(teamNum));
                // Sort by match_id
                allTeamMatches.sort((a, b) => a.match_id.localeCompare(b.match_id));

                // Calc stats for display in header of match list maybe? Or just keep rows here. 
                // The stats will be calculated in renderStandings and passed or recalculated.
                // For now, this function just returns HTML strings for rows.

                return allTeamMatches.map(m => {
                    const isRed = m.red.includes(teamNum);
                    const alliance = isRed ? 'Red' : 'Blue';
                    const score = isRed ? m.red_score : m.blue_score;
                    const auto = isRed ? m.red_auto : m.blue_auto; // Should be populated now
                    const dc = isRed ? m.red_dc : m.blue_dc;
                    const rp = isRed ? m.red_rp : m.blue_rp;
                    const color = isRed ? 'text-red-400' : 'text-blue-400';
                    return `
                        <tr class="border-b border-gray-700/50 hover:bg-gray-700/50 transition">
                            <td class="py-1 font-mono text-[10px] text-gray-400">${m.match_id}</td>
                            <td class="py-1"><span class="${color} font-bold text-[10px] uppercase">${alliance}</span></td>
                            <td class="py-1 text-right text-green-300 font-mono">${auto !== undefined ? auto : '-'}</td>
                            <td class="py-1 text-right text-blue-300 font-mono">${dc !== undefined ? dc : '-'}</td>
                            <td class="py-1 text-right font-bold text-white font-mono">${score}</td>
                            <td class="py-1 text-center text-yellow-500 font-mono">${rp}</td>
                        </tr>
                    `;
                }).join('');
            },

            generateSparkline(matches) {
                if (!matches || matches.length < 2) return '<div class="h-full w-full flex items-center justify-center text-xs text-gray-500">Not enough data</div>';

                const width = 300;
                const height = 80; // Increased height for labels
                const padding = { top: 15, bottom: 15, left: 10, right: 40 }; // Right padding for "Pred" label

                const chartW = width - padding.left - padding.right;
                const chartH = height - padding.top - padding.bottom;

                // 1. History Data
                const scores = matches.map(m => m.score);
                const avg = scores.reduce((a, b) => a + b, 0) / scores.length;

                // Linear Regression
                const n = scores.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = scores.reduce((a, b) => a + b, 0);
                const sumXY = scores.reduce((a, b, i) => a + (i * b), 0);
                const sumXX = (n * (n - 1) * (2 * n - 1)) / 6;

                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                // 2. Prediction (next 3 matches is enough for trend visualization, 5 was wide)
                const predCount = 3;
                const predictions = Array.from({ length: predCount }, (_, i) => {
                    const x = n + i;
                    return Math.max(0, slope * x + intercept);
                });
                const finalPred = predictions[predCount - 1];

                // Scaling
                const allPoints = [...scores, ...predictions];
                const min = 0; // Always start at 0 for score
                const max = Math.max(...allPoints, avg) * 1.1; // 10% headroom
                const range = max - min || 1;

                const totalPoints = scores.length + predCount; // e.g., 3 + 3 = 6 points
                const stepX = chartW / (totalPoints - 1);

                // Helper to map values to SVG coordinates
                const getY = (val) => chartH + padding.top - ((val - min) / range * chartH);
                const getX = (idx) => padding.left + (idx * stepX);

                // --- Build Paths ---

                // History
                let pathD = "";
                scores.forEach((s, i) => {
                    const x = getX(i);
                    const y = getY(s);
                    pathD += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
                });

                // Prediction area (connect from last history point)
                let predD = "";
                const startX = getX(scores.length - 1);
                // We use the ACTUAL last score to start the line, so it connects visually
                const startY = getY(scores[scores.length - 1]);
                predD += `M ${startX} ${startY}`;

                predictions.forEach((p, i) => {
                    const x = getX(scores.length + i);
                    const y = getY(p);
                    predD += ` L ${x} ${y}`;
                });

                // Fill Area (History Only)
                const lastHistoryX = getX(scores.length - 1);
                const fillD = `${pathD} L ${lastHistoryX} ${height} L ${padding.left} ${height} Z`;

                // Average Line
                const yAvg = getY(avg);
                const avgLine = `M ${padding.left} ${yAvg} L ${width - padding.right} ${yAvg}`;

                // --- Labels ---
                const predY = getY(finalPred);
                const predX = width - padding.right + 5;

                // Determine label positions to avoid overlap opacity
                // Avg Label
                const avgLabelY = Math.min(chartH + padding.top - 5, Math.max(padding.top + 10, yAvg));

                // --- Tooltips ---
                const tooltips = matches.map((m, i) => {
                    const x = getX(i);
                    return `<rect x="${x - (stepX / 2)}" y="0" width="${stepX}" height="${height}" fill="transparent" class="cursor-pointer">
                        <title>Match ${m.match_id}: ${m.score} pts\n(Auto: ${m.auto}, Tele: ${m.dc})</title>
                    </rect>`;
                }).join('');

                return `
                    <svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="overflow-visible font-mono">
                        <defs>
                            <linearGradient id="gradScore" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stop-color="#818cf8" stop-opacity="0.2" />
                                <stop offset="100%" stop-color="#818cf8" stop-opacity="0" />
                            </linearGradient>
                            <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
                                <feGaussianBlur stdDeviation="2" result="blur" />
                                <feComposite in="SourceGraphic" in2="blur" operator="over" />
                            </filter>
                        </defs>
                        
                        <!-- Grid Lines (Horizontal) -->
                        <line x1="${padding.left}" y1="${padding.top}" x2="${width - padding.right}" y2="${padding.top}" stroke="#374151" stroke-width="0.5" stroke-dasharray="2,2"/>
                        <line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="#374151" stroke-width="0.5"/>

                        <!-- Average Line -->
                        <path d="${avgLine}" stroke="#6b7280" stroke-width="1" stroke-dasharray="3,3" />
                         <rect x="${padding.left}" y="${avgLabelY - 7}" width="36" height="10" rx="2" fill="#1f2937" opacity="0.8"/>
                        <text x="${padding.left + 2}" y="${avgLabelY}" font-size="8" fill="#9ca3af" font-weight="bold">Avg ${avg.toFixed(0)}</text>

                        <!-- Areas and Lines -->
                        <path d="${fillD}" fill="url(#gradScore)" stroke="none" />
                        <path d="${pathD}" fill="none" stroke="#818cf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        <path d="${predD}" fill="none" stroke="#fbbf24" stroke-width="2" stroke-dasharray="3,3" stroke-linecap="round" />

                        <!-- Points (History) -->
                        ${scores.map((s, i) => `<circle cx="${getX(i)}" cy="${getY(s)}" r="3" fill="#1f2937" stroke="#c7d2fe" stroke-width="1.5" />`).join('')}
                        
                        <!-- Points (Prediction) -->
                        ${predictions.map((p, i) => `<circle cx="${getX(scores.length + i)}" cy="${getY(p)}" r="2" fill="#1f2937" stroke="#fbbf24" stroke-width="1" />`).join('')}

                        <!-- Pred Label -->
                        <text x="${width - padding.right + 2}" y="${predY + 3}" font-size="9" fill="#fbbf24" font-weight="bold"> ${finalPred.toFixed(0)}?</text>
                        
                        ${tooltips}
                    </svg>
                `;
            },

            setCloudStatus(msg, color) {
                const el = document.getElementById('cloud-status');
                el.textContent = msg;
                el.className = `text-center text-sm mb-4 h-6 ${color}`;
            }
        };

        /**
         * OPR Math Helper (Gaussian Elimination)
         * Solves Ax = b
         */
        function solveLinearSystem(A, b) {
            const n = A.length;
            // Augment A with b
            const M = A.map((row, i) => [...row, b[i]]);

            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                }

                // Swap
                [M[i], M[maxRow]] = [M[maxRow], M[i]];

                // Make 1
                const pivot = M[i][i];
                if (Math.abs(pivot) < 1e-10) continue; // Singular or close to it

                for (let j = i; j <= n; j++) M[i][j] /= pivot;

                // Eliminate
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = M[k][i];
                        for (let j = i; j <= n; j++) M[k][j] -= factor * M[i][j];
                    }
                }
            }

            return M.map(row => row[n]);
        }

        function solveOPR(matches, teamNumbers) {
            const uniqueTeams = Array.from(new Set(teamNumbers));
            const numTeams = uniqueTeams.length;
            const teamToIndex = new Map(uniqueTeams.map((team, i) => [team, i]));

            // Initialize A matrix and b vector
            const A = Array(numTeams).fill(0).map(() => Array(numTeams).fill(0));
            const b = Array(numTeams).fill(0);

            matches.forEach(match => {
                const redTeams = match.red.filter(t => t && teamToIndex.has(t));
                const blueTeams = match.blue.filter(t => t && teamToIndex.has(t));

                const redScore = (typeof match.red_score_np !== 'undefined') ? match.red_score_np : match.red_score;
                const blueScore = (typeof match.blue_score_np !== 'undefined') ? match.blue_score_np : match.blue_score;

                // Red Alliance
                for (const team1 of redTeams) {
                    const idx1 = teamToIndex.get(team1);
                    b[idx1] += redScore;
                    for (const team2 of redTeams) {
                        const idx2 = teamToIndex.get(team2);
                        A[idx1][idx2] += 1;
                    }
                }

                // Blue Alliance
                for (const team1 of blueTeams) {
                    const idx1 = teamToIndex.get(team1);
                    b[idx1] += blueScore;
                    for (const team2 of blueTeams) {
                        const idx2 = teamToIndex.get(team2);
                        A[idx1][idx2] += 1;
                    }
                }
            });

            const solution = solveLinearSystem(A, b);

            const oprResults = {};
            uniqueTeams.forEach((team, i) => {
                oprResults[team] = solution[i] || 0; // Default to 0 if no solution (e.g., singular matrix)
            });

            return oprResults;
        }

        // BOOT

        // Update Firebase status in modal
        // Update Firebase status
        const syncStatusEl = document.getElementById('sync-status');
        if (syncStatusEl) {
            if (firebaseEnabled) {
                syncStatusEl.textContent = 'Live - Waiting for changes';
                syncStatusEl.className = 'text-green-400 font-bold';
            } else {
                syncStatusEl.textContent = 'Offline - Local storage only';
                syncStatusEl.className = 'text-gray-400';
            }
        }


        // Auto-load from cloud on init
        if (firebaseEnabled) {
            app.forceSyncFromCloud();
        }


        document.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>

</html>